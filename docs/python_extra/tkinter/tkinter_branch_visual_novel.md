# Ветка A: Визуальная новелла на tkinter

## Вступление

В этой ветке мы будем строить простую текстовую игру, где:

- На экране выводится текст (описание сцены, диалоги персонажей)
- Ниже появляются кнопки с вариантами выбора
- Когда ты нажимаешь кнопку, история движется дальше

Ты сможешь написать свою историю. Может быть, приключение, детектив, фэнтези — что угодно.

**Главная идея**: структурировать историю как набор сцен, каждая сцена знает, какие варианты выбора есть и куда они
ведут.

---

## Модуль 0: Основные элементы tkinter

### Задание 0.1 — Создаём первое окно

**Что мы делаем**: просто создаём пустое окно, которое появляется на экране и может закрываться.

**Новый элемент: `Tk()`**

`Tk()` — это главный объект вашего приложения. Это как лист бумаги, на который вы будете что-то рисовать (добавлять
кнопки, текст и так далее).

Простыми словами:

- `Tk()` создаёт окно.
- `.title()` устанавливает текст в верхней части окна (название программы).
- `.geometry()` устанавливает размер окна (ширина и высота в пикселях).
- `.mainloop()` запускает бесконечный цикл, который следит за тем, произошло ли что-то (нажата ли кнопка, закрыто ли
  окно).

**Код:**

```python
import tkinter as tk


# Создаём главное окно
root = tk.Tk()

# Устанавливаем название окна
root.title( "Моя первая визуальная новелла" )

# Устанавливаем размер: ширина 600 пикселей, высота 400 пикселей
root.geometry( "600x400" )

# Запускаем приложение (цикл событий)
root.mainloop()
```

**Что происходит пошагово:**

1. `import tkinter as tk` — подключаем библиотеку tkinter.
2. `root = tk.Tk()` — создаём окно и сохраняем его в переменной `root`.
3. `root.title(...)` — пишем название в полосе окна.
4. `root.geometry(...)` — говорим операционной системе: сделай окно таким размером.
5. `root.mainloop()` — начинаем слушать события (если пользователь нажимает кнопку, закрывает окно и т.д.).

**Что попробовать:**

- Поменяй цифры в `.geometry("600x400")` на другие (например, `"800x600"`).
- Поменяй текст в `.title()` на своё название.
- Запусти программу и убедись, что окно появляется и закрывается.

---

### Задание 0.2 — Добавляем текст (Label)

**Что мы делаем**: добавляем на экран надпись.

**Новый элемент: `Label`**

`Label` — это элемент, который просто выводит текст. Ничего специального с ним не делается, он просто сидит и показывает
информацию.

Простыми словами:

- `Label` — это надпись на стене.
- `text` — что написано на этой надписи.
- `.pack()` — способ разместить надпись на экране (мы просто говорим: «положи это на форму», а tkinter сам выберет,
  где).

**Код:**

```python
import tkinter as tk


root = tk.Tk()
root.title( "Надпись" )
root.geometry( "600x400" )

# Создаём надпись
label = tk.Label( root, text = "Добро пожаловать в мою новеллу!" )

# Помещаем надпись на форму с отступом сверху (pady = отступ по вертикали)
label.pack( pady = 20 )

root.mainloop()
```

**Что происходит:**

1. `tk.Label(root, text="...")` — создаём надпись внутри окна `root` с текстом "Добро пожаловать...".
2. `.pack(pady=20)` — размещаем надпись на форме с пустым пространством (20 пикселей) сверху и снизу от неё.

**Что попробовать:**

- Поменяй текст в `text="..."`.
- Измени цифру в `pady=20` на другую (например, `100` или `5`). Видишь, как надпись движется выше или ниже?
- Попробуй добавить ещё одну надпись (скопируй строки с `label` и переименуй переменную на `label2`).

---

### Задание 0.3 — Кнопка и действие (Button)

**Что мы делаем**: создаём кнопку, которая при нажатии выполняет какое-то действие.

**Новый элемент: `Button` и функции**

`Button` — это кнопка. Когда ты на неё нажимаешь, она выполняет функцию (специальный блок кода).

**Функция** — это блок кода, который может быть выполнен в любой момент. Например:

```python
def my_function():
	print( "Я выполнилась!" )
```

`def` — ключевое слово, которое говорит: «Дальше идёт определение функции». Функция делает всё, что написано с отступом
ниже.

**Код:**

```python
import tkinter as tk


# Функция, которая выполнится при нажатии кнопки
def on_button_click():
	print( "Ты нажал кнопку!" )


root = tk.Tk()
root.title( "Кнопка" )
root.geometry( "600x400" )

# Создаём надпись
label = tk.Label( root, text = "Нажми кнопку" )
label.pack( pady = 20 )

# Создаём кнопку
# command=on_button_click говорит: "когда нажмут, выполни функцию on_button_click"
button = tk.Button( root, text = "Нажми меня!", command = on_button_click )
button.pack( pady = 10 )

root.mainloop()
```

**Что происходит:**

1. `def on_button_click():` — мы определяем функцию, которая выполнится при нажатии кнопки.
2. `print(...)` — внутри функции мы выводим текст в консоль.
3. `tk.Button(root, text="...", command=on_button_click)` — создаём кнопку с текстом и говорим, что при нажатии вызвать
   функцию `on_button_click`.
4. `.pack(pady=10)` — размещаем кнопку на форме.

**Что попробовать:**

- Нажми кнопку и посмотри в консоль (где выводится текст программы). Там должно появиться "Ты нажал кнопку!".
- Поменяй текст в `print()`.
- Попробуй добавить в функцию несколько строк кода (например, два `print` в одной функции).

---

### Задание 0.4 — Ввод текста (Entry)

**Что мы делаем**: создаём поле, в которое пользователь может вводить текст, и потом обрабатываем этот текст.

**Новый элемент: `Entry`**

`Entry` — это однострочное поле ввода. Пользователь может в него печатать.

Чтобы получить текст из `Entry`, используем метод `.get()`.

**Код:**

```python
import tkinter as tk


def show_message():
	# Берём текст из поля ввода
	user_text = entry.get()

	# Выводим текст в консоль
	print( f"Ты ввёл: {user_text}" )


root = tk.Tk()
root.title( "Ввод текста" )
root.geometry( "600x400" )

# Надпись
label = tk.Label( root, text = "Введи своё имя:" )
label.pack( pady = 10 )

# Поле ввода
entry = tk.Entry( root )
entry.pack( pady = 10 )

# Кнопка
button = tk.Button( root, text = "Отправить", command = show_message )
button.pack( pady = 10 )

root.mainloop()
```

**Что происходит:**

1. `entry = tk.Entry(root)` — создаём поле ввода.
2. `entry.get()` — получаем текст, который ввёл пользователь.
3. `print(f"Ты ввёл: {user_text}")` — выводим в консоль. `f"..."` это специальная строка (f-string), которая позволяет
   вставлять значения переменных прямо в текст.

**Что попробовать:**

- Введи своё имя и нажми кнопку. В консоли должно появиться "Ты ввёл: [твоё имя]".
- Поменяй формат вывода, например: `print(f"Привет, {user_text}!")`

---

### Задание 0.5 — Изменение элементов (config)

**Что мы делаем**: меняем текст в надписи или кнопке не при создании, а во время работы программы.

**Новый элемент: `.config()`**

`.config()` — это метод, который позволяет менять свойства элемента уже после его создания.

**Код:**

```python
import tkinter as tk


def update_label():
	# Меняем текст надписи
	label.config( text = "Ты нажал кнопку!" )


root = tk.Tk()
root.title( "Изменение текста" )
root.geometry( "600x400" )

# Создаём надпись с начальным текстом
label = tk.Label( root, text = "Первоначальный текст" )
label.pack( pady = 20 )

# Создаём кнопку
button = tk.Button( root, text = "Поменять текст", command = update_label )
button.pack( pady = 10 )

root.mainloop()
```

**Что происходит:**

1. `label.config(text="...")` — мы меняем свойство `text` надписи `label` на новое значение.
2. Каждый раз, когда нажимаешь кнопку, функция `update_label` меняет текст.

**Что попробовать:**

- Нажми кнопку несколько раз. Видишь, текст меняется?
- Поменяй текст на что-нибудь другое.
- Попробуй менять не только текст, но и цвет: `label.config(text="...", fg="red")` (fg = foreground, то есть цвет
  текста).

---

### Задание 0.6 — Контейнеры (Frame)

**Что мы делаем**: группируем элементы в контейнеры, чтобы располагать их рядом, а не один под другим.

**Новый элемент: `Frame`**

`Frame` — это коробка, контейнер. Внутри можно раскладывать другие элементы. Это помогает организовать расположение.

**Код без Frame (элементы всегда в столбик):**

```python
import tkinter as tk


root = tk.Tk()
root.title( "Без Frame" )
root.geometry( "600x400" )

label1 = tk.Label( root, text = "Этикетка 1" )
label1.pack()

label2 = tk.Label( root, text = "Этикетка 2" )
label2.pack()

root.mainloop()
```

**Код с Frame (элементы в одной строке):**

```python
import tkinter as tk


root = tk.Tk()
root.title( "С Frame" )
root.geometry( "600x400" )

# Создаём контейнер (Frame)
frame = tk.Frame( root )
frame.pack( pady = 20 )

# Создаём два элемента внутри контейнера
label1 = tk.Label( frame, text = "Этикетка 1" )
label1.pack( side = "left", padx = 10 )

label2 = tk.Label( frame, text = "Этикетка 2" )
label2.pack( side = "left", padx = 10 )

root.mainloop()
```

**Что происходит:**

1. `tk.Frame(root)` — создаём контейнер внутри главного окна.
2. `pack(side="left", padx=10)` — `side="left"` означает, что элементы будут выстраиваться слева направо (если бы было
   `"top"`, они были бы снизу вверх как обычно).
3. `padx=10` — горизонтальный отступ (пустое место слева и справа).

**Что попробовать:**

- Попробуй менять `side` на `"right"`, `"top"`, `"bottom"` и смотри, как меняется расположение.
- Добавь третий элемент внутри контейнера.

---

## Модуль A: Визуальная новелла

Теперь мы будем строить саму новеллу!

---

### A1. Базовая сцена с кнопкой "Далее"

**Что мы делаем**: создаём окно, в котором текст истории выводится в одном месте, а внизу есть кнопка "Далее", которая
показывает следующую часть текста.

**Новое понятие: список (list)**

Список — это контейнер, в котором хранятся несколько значений. Например:

```python
colors = ["красный", "синий", "жёлтый"]
```

Чтобы получить элемент из списка, используем индекс (номер):

```python
print( colors[0] )  # выведет "красный"
print( colors[1] )  # выведет "синий"
```

Индексы начинаются с нуля!

**Код:**

```python
import tkinter as tk


root = tk.Tk()
root.title( "Моя новелла" )
root.geometry( "600x400" )

# Список текстов сцен
scenes = [
	"Ты просыпаешься в странной комнате.\nОкна занавешены тёмной тканью.\nДвета мигает лампа на потолке.",
	"Ты подходишь к двери.\nОна заперта на ключ.\nТы слышишь звук шагов снаружи.",
	"Звуки приближаются.\nТвоё сердце бьётся быстрее.\nЧто-то окапывается в замке..."
]

# Переменная, которая отслеживает, какую сцену мы показываем
current_scene = 0

# Создаём надпись, где будет текст
label = tk.Label( root, text = scenes[current_scene], wraplength = 580, justify = "left" )
label.pack( pady = 20 )


# Функция для переходы на следующую сцену
def next_scene():
	global current_scene
	current_scene = current_scene + 1

	# Проверяем, не вышли ли мы за границы списка
	if current_scene >= len( scenes ):
		label.config( text = "Конец истории." )
		button_next.config( state = "disabled" )  # Отключаем кнопку
	else:
		label.config( text = scenes[current_scene] )


# Создаём кнопку
button_next = tk.Button( root, text = "Далее", command = next_scene )
button_next.pack( pady = 10 )

root.mainloop()
```

**Что происходит пошагово:**

1. `scenes = [...]` — создаём список с текстами.
2. `current_scene = 0` — переменная, которая отслеживает, какую сцену мы показываем (начинаем с нулевой, то есть
   первой).
3. `wraplength=580` — текст автоматически переносится, если он длиннее 580 пикселей.
4. `justify="left"` — текст выравнивается по левому краю.
5. `global current_scene` — говорим Python: «Мы хотим менять переменную `current_scene`, а не создавать новую
   локальную».
6. `len(scenes)` — количество элементов в списке.
7. `button_next.config(state="disabled")` — отключаем кнопку (она становится серой и не нажимается).

**Что попробовать:**

- Добавь свои сцены в список.
- Поменяй текст на кнопке (например, "Продолжить").
- Добавь кнопку "Назад", которая показывает предыдущую сцену (для этого нужно вычесть 1 вместо добавления).

---

### A2. Развилка: два варианта выбора

**Что мы делаем**: делаем историю ветвящейся. На каждой сцене есть два варианта выбора, и в зависимости от выбора мы
переходим в разные места истории.

**Новое понятие: словарь (dictionary)**

Словарь — это контейнер, в котором хранятся пары "ключ: значение". Например:

```python
person = {
	"name": "Иван",
	"age" : 25,
	"city": "Москва"
}

print( person["name"] )  # выведет "Иван"
```

В нашем случае мы будем использовать словарь для хранения информации о сценах. Например, каждая сцена будет иметь:

- `"text"` — текст сцены
- `"choices"` — список вариантов выбора (где каждый вариант содержит текст кнопки и ID следующей сцены)

**Код:**

```python
import tkinter as tk


# Словарь сцен
# Ключи — это ID сцен (например, "start", "room", "ending")
# Значения — словари с информацией о сцене
scenes = {
	"start"     : {
		"text"   : "Ты стоишь у старого дома.\nНа крыльцо ведут заборы деревянные.\nЧто ты сделаешь?",
		"choices": [
			("Войти в дом", "inside"),
			("Обойти дом", "around")
		]
	},
	"inside"    : {
		"text"   : "Ты входишь в дом.\nВнутри темно и пыльно.\nТы видишь две двери: слева и справа.",
		"choices": [
			("Открыть левую дверь", "left_room"),
			("Открыть правую дверь", "right_room")
		]
	},
	"around"    : {
		"text"   : "Ты обходишь дом и находишь открытое окно в подвал.",
		"choices": [
			("Залезть в подвал", "basement"),
			("Вернуться к дому", "start")
		]
	},
	"left_room" : {
		"text"   : "В левой комнате стоит старый письменный стол.\nПосредине листок бумаги с письмом.",
		"choices": [
			("Прочитать письмо", "letter"),
			("Вернуться", "inside")
		]
	},
	"right_room": {
		"text"   : "Правая комната полностью пуста.\nТолько в углу старая зеркало.",
		"choices": [
			("Вернуться", "inside"),
		]
	},
	"basement"  : {
		"text"   : "В подвале ты находишь сундук.\nВнутри сундука что-то блестит...",
		"choices": [
			("Конец истории", "ending"),
		]
	},
	"letter"    : {
		"text"   : "Письмо написано старым почерком:\n'Если ты читаешь это, значит ты нашёл путь.'",
		"choices": [
			("Конец истории", "ending"),
		]
	},
	"ending"    : {
		"text"   : "Конец истории. Спасибо за прохождение!",
		"choices": []
	}
}

root = tk.Tk()
root.title( "Визуальная новелла" )
root.geometry( "600x500" )

# Переменная, в которой хранится ID текущей сцены
current_scene_id = "start"

# Надпись для текста
text_label = tk.Label( root, text = "", wraplength = 580, justify = "left" )
text_label.pack( pady = 20 )

# Контейнер для кнопок
buttons_frame = tk.Frame( root )
buttons_frame.pack( pady = 10 )

# Создаём две кнопки (они будут скрыты, пока им не дадим текст)
button1 = tk.Button( buttons_frame, text = "" )
button1.pack( side = "left", padx = 10 )

button2 = tk.Button( buttons_frame, text = "" )
button2.pack( side = "left", padx = 10 )


# Функция для отображения сцены
def show_scene( scene_id ):
	global current_scene_id
	current_scene_id = scene_id

	# Получаем информацию о сцене
	scene = scenes[scene_id]

	# Выводим текст сцены
	text_label.config( text = scene["text"] )

	# Получаем варианты выбора
	choices = scene["choices"]

	# Если есть первый вариант, настраиваем первую кнопку
	if len( choices ) > 0:
		button1.config(
			text = choices[0][0],
			command = lambda: show_scene( choices[0][1] )
		)
		button1.pack( side = "left", padx = 10 )
	else:
		button1.pack_forget()  # Скрываем кнопку, если нет варианта

	# Если есть второй вариант, настраиваем вторую кнопку
	if len( choices ) > 1:
		button2.config(
			text = choices[1][0],
			command = lambda: show_scene( choices[1][1] )
		)
		button2.pack( side = "left", padx = 10 )
	else:
		button2.pack_forget()  # Скрываем кнопку, если нет варианта


# Показываем первую сцену
show_scene( current_scene_id )

root.mainloop()
```

**Что происходит пошагово:**

1. `scenes = {...}` — словарь всех сцен. Каждая сцена имеет ID (ключ), текст и варианты выбора.
2. `"choices": [("Войти в дом", "inside"), ...]` — каждый выбор это кортеж (упорядоченная пара) из текста кнопки и ID
   следующей сцены.
3. `lambda: show_scene(choices[0][1])` — это особенная конструкция. `lambda` создаёт анонимную функцию на лету. Нам
   нужна функция, которая при нажатии кнопки вызовет `show_scene(choices[0][1])`. `lambda` позволяет это сделать.
4. `pack_forget()` — скрывает элемент (делает его невидимым и не занимающим место).

**Что попробовать:**

- Измени текст в сценах.
- Добавь новую сцену (например, "treasure" после "basement").
- Добавь больше развилок (выборов) в существующие сцены.
- Удали одну из сцен и посмотри, что произойдёт при попытке перейти туда (это ошибка, которая поможет тебе понять, как
  устроено).

---

### A3. Пишем свою историю

**Задание:**

- Скопируй весь код из A2.
- Полностью переделай `scenes` под свою историю.
- Минимум требования:
	- 6-8 сцен
	- Минимум 2 места с выбором (развилки)
	- 1-2 концовки (разные концовки в зависимости от выбора)

**Подсказки:**

- Можешь написать историю про:
	- Спасение заложника
	- Поиск потерянного артефакта
	- Выживание в инопланетной колонии
	- Расследование преступления
	- Побег из замка
	- Или что-то своё!

- Перед тем как писать код, на бумаге нарисуй схему: какие сцены есть и как они соединены стрелками.

---

### A4. Красивый текст (Widget Text)

**Что мы делаем**: вместо `Label` используем `Text` — специальный виджет для больших текстов.

**Новый элемент: `Text`**

`Text` — это многострочное поле для текста. Оно лучше, чем `Label`, для больших текстов, потому что:

- Может быть очень длинным
- Текст можно прокручивать
- Можно менять форматирование отдельных частей

**Код:**

```python
import tkinter as tk


root = tk.Tk()
root.title( "Text пример" )
root.geometry( "600x400" )

# Создаём текстовое поле
text_widget = tk.Text( root, width = 70, height = 15, wrap = "word" )
text_widget.pack( pady = 10 )

# Вставляем текст в позицию "1.0" (начало)
text_widget.insert( "1.0", "Это многострочный текст.\nЧто-то здесь происходит." )

root.mainloop()
```

**Что происходит:**

1. `width=70, height=15` — ширина (символы) и высота (строки) текстового поля.
2. `wrap="word"` — если текст длиннее, чем ширина, он переносится на новую строку по словам.
3. `text_widget.insert("1.0", "...")` — вставляет текст. `"1.0"` означает: строка 1, символ 0 (начало).

**Теперь интегрируем в новеллу:**

```python
import tkinter as tk


scenes = {
	"start" : {
		"text"   : "Ты просыпаешься...",
		"choices": [("Далее", "next")]
	},
	"next"  : {
		"text"   : "Следующая сцена...",
		"choices": [("Конец", "ending")]
	},
	"ending": {
		"text"   : "Конец истории.",
		"choices": []
	}
}

root = tk.Tk()
root.title( "Визуальная новелла" )
root.geometry( "600x500" )

current_scene_id = "start"

# Вместо Label, используем Text
text_widget = tk.Text( root, width = 70, height = 15, wrap = "word" )
text_widget.pack( pady = 10 )

# Делаем текстовое поле только для чтения (пользователь не может редактировать)
text_widget.config( state = "disabled" )

buttons_frame = tk.Frame( root )
buttons_frame.pack( pady = 10 )

button1 = tk.Button( buttons_frame, text = "" )
button1.pack( side = "left", padx = 10 )

button2 = tk.Button( buttons_frame, text = "" )
button2.pack( side = "left", padx = 10 )


def show_scene( scene_id ):
	global current_scene_id
	current_scene_id = scene_id
	scene = scenes[scene_id]

	# Очищаем старый текст
	text_widget.config( state = "normal" )  # Разрешаем редактирование
	text_widget.delete( "1.0", "end" )  # Удаляем всё (от 1.0 до конца)
	text_widget.insert( "1.0", scene["text"] )  # Вставляем новый текст
	text_widget.config( state = "disabled" )  # Запрещаем редактирование

	choices = scene["choices"]

	if len( choices ) > 0:
		button1.config(
			text = choices[0][0],
			command = lambda: show_scene( choices[0][1] )
		)
		button1.pack( side = "left", padx = 10 )
	else:
		button1.pack_forget()

	if len( choices ) > 1:
		button2.config(
			text = choices[1][0],
			command = lambda: show_scene( choices[1][1] )
		)
		button2.pack( side = "left", padx = 10 )
	else:
		button2.pack_forget()


show_scene( current_scene_id )

root.mainloop()
```

**Что происходит:**

1. `text_widget.config(state="disabled")` — делает поле доступным только для чтения (пользователь не может печатать).
2. `text_widget.delete("1.0", "end")` — удаляет весь текст (от строки 1, символа 0 до конца).
3. `text_widget.insert("1.0", "...")` — вставляет новый текст.

**Что попробовать:**

- Добавь очень длинный текст в одну сцену и убедись, что он прокручивается.
- Измени `wrap` на `"none"` и посмотри разницу.
- Попробуй менять цвет текста: `text_widget.config(fg="blue")`.

---

## Итоговый проект для ветки A

Напиши полную визуальную новеллу (6-10 сцен) со следующими требованиями:

- [ ] Минимум 2 точки ветвления (разные варианты выбора, ведущие в разные сцены)
- [ ] 2-3 разные концовки
- [ ] Используй `Text` для вывода текста
- [ ] Красивые описания (несколько предложений в каждой сцене)
- [ ] Кнопки с логичными названиями выборов

**Идеи для историй:**

- Приключение в замке
- Расследование загадочного события
- Путешествие через лес
- Спасение друга
- Выбор пути (работа или путешествие и т.д.)
- Или придумай свою!
